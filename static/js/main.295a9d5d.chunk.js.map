{"version":3,"sources":["actions/actions.js","reducers/index.js","Map/hereTileLayers.js","Map/Map.jsx","Controls/Settings.jsx","Controls/Control.jsx","App.jsx","index.js"],"names":["hereAppCode","hereAppId","UPDATE_TEXTINPUT","RECEIVE_GEOCODE_RESULTS","REQUEST_GEOCODE_RESULTS","UPDATE_CENTER","UPDATE_SETTINGS","RECEIVE_ISOCHRONES_RESULTS","REQUEST_ISOCHRONES_RESULTS","processIsochronesResponse","json","dispatch","results","response","isoline","length","reverse","parseIsochronesResponse","receiveIsochronesResults","type","processIsolineSettings","settings","isolineParameters","mode","traffic","rangetype","start","isochronesCenter","lat","lng","ranges","rangeInSeconds","range","value","intervalInSeconds","interval","push","join","rangeInMeters","intervalInMeters","requestIsochronesResults","processGeocodeResponse","latLng","Response","View","processedResults","Result","address","Location","LocationType","title","Address","Label","description","PostalCode","displayposition","DisplayPosition","Latitude","Longitude","parseGeocodeResponse","receiveGeocodeResults","payload","requestGeocodeResults","updateTextInput","initialIsochronesControlsState","userInput","geocodeResults","isochrones","isFetching","isFetchingIsochrones","max","rootReducer","combineReducers","isochronesControls","state","action","inputValue","HereTileLayers","HERE","L","extend","options","subdomains","minZoom","maxZoom","scheme","resource","mapId","format","appId","appCode","initialize","schemeStart","this","split","tileResolution","retina","tileServer","indexOf","tileUrl","_attributionUrl","template","prototype","call","_attributionText","onAdd","map","_attributionBBoxes","_fetchAttributionBBoxes","onRemove","_map","attributionControl","removeAttribution","off","_findCopyrightBBox","xmlhttp","XMLHttpRequest","onreadystatechange","readyState","status","_parseAttributionBBoxes","JSON","parse","responseText","open","send","providers","normal","i","boxes","j","box","on","_attributionProviders","visibleProviders","zoom","getZoom","visibleBounds","getBounds","minLevel","maxLevel","overlaps","attributions","provider","alt","label","attributionText","addAttribution","here","opts","style","width","height","hereReducedDay","markersLayer","featureGroup","isochronesLayer","southWest","northEast","mapParams","center","zoomControl","maxBounds","latLngBounds","layers","Map","clearLayers","props","cnt","scaleHsl","chroma","scale","colors","isochrone","component","isochroneComponent","polygon","shape","coordString","fillColor","weight","opacity","color","pane","addTo","fitBounds","circleMarker","bindTooltip","permanent","openTooltip","setView","addIsochronesCenter","addIsochrones","createPane","baseMaps","control","position","brand","div","DomUtil","create","innerHTML","addControl","id","React","Component","connect","Settings","controls","settingName","setting","updateSettings","rangeSettings","min","step","onChange","alignRangeInterval","intervalSettings","className","Divider","size","Button","Group","basic","Object","keys","pedestrian","car","key","active","onClick","handleSettings","enabled","disabled","distance","time","discrete","inverted","segmentStyle","zIndex","top","left","maxHeight","overflow","padding","Control","handleSearchChange","event","target","fetchGeocodeResults","handleResultSelect","e","result","handleFetchIsochrones","url","URL","params","app_id","app_code","search","URLSearchParams","fetch","then","data","catch","error","console","bind","debounce","userTextInput","searchtext","Segment","Search","onSearchChange","onResultSelect","fluid","input","loading","placeholder","circular","icon","App","middleware","thunk","store","createStore","reducer","composeWithDevTools","applyMiddleware","render","document","getElementById"],"mappings":"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","file":"static/js/main.295a9d5d.chunk.js","sourcesContent":["// use these or add your own credentials\r\nconst hereAppCode = '0XXQyxbiCjVU7jN2URXuhg'\r\nconst hereAppId = 'yATlKFDZwdLtjHzyTeCK'\r\n\r\nexport const UPDATE_TEXTINPUT = 'UPDATE_TEXTINPUT'\r\nexport const RECEIVE_GEOCODE_RESULTS = 'RECEIVE_GEOCODE_RESULTS'\r\nexport const REQUEST_GEOCODE_RESULTS = 'REQUEST_GEOCODE_RESULTS'\r\nexport const UPDATE_CENTER = 'UPDATE_CENTER'\r\nexport const UPDATE_SETTINGS = 'UPDATE_SETTINGS'\r\nexport const RECEIVE_ISOCHRONES_RESULTS = 'RECEIVE_ISOCHRONES_RESULTS'\r\nexport const REQUEST_ISOCHRONES_RESULTS = 'REQUEST_ISOCHRONES_RESULTS'\r\n\r\nexport const fetchHereIsochrones = payload => dispatch => {\r\n\r\n  // we let the app know that we are calling the isochrones API\r\n  dispatch(requestIsochronesResults())\r\n\r\n  // we generate our GET parameters from the settigns\r\n  const isolineParameters = processIsolineSettings(payload.settings)\r\n\r\n  // as seen before :)\r\n  let url = new URL(\r\n      'https://isoline.route.api.here.com/routing/7.2/calculateisoline.json'\r\n    ),\r\n    params = {\r\n      app_id: hereAppId,\r\n      app_code: hereAppCode,\r\n      ...isolineParameters\r\n    }\r\n\r\n  url.search = new URLSearchParams(params)\r\n\r\n  return fetch(url)\r\n    .then(response => response.json())\r\n    .then(data =>\r\n      dispatch(processIsochronesResponse(data))\r\n    )\r\n    .catch(error => console.error(error))\r\n}\r\n\r\n\r\nconst parseIsochronesResponse = json => {\r\n  if (json.response && json.response.isoline.length > 0) {\r\n    const isolinesReversed = json.response.isoline.reverse()\r\n    return isolinesReversed\r\n  }\r\n  return []\r\n}\r\n\r\nconst processIsochronesResponse = (json) => dispatch => {\r\n  // a small trick: we reverse the polygons that the largest comes first :-)\r\n  const results = parseIsochronesResponse(json)\r\n\r\n  // we have received our results\r\n  dispatch(receiveIsochronesResults(results))\r\n}\r\n\r\n\r\nexport const receiveIsochronesResults = results => ({\r\n  type: RECEIVE_ISOCHRONES_RESULTS,\r\n  results: results\r\n})\r\n\r\nconst processIsolineSettings = (settings) => {\r\n  let isolineParameters = {}\r\n\r\n  // we prepare the GET parameters according to the HERE Maps Isochrones API docs\r\n  isolineParameters.mode = `fastest;${settings.mode};traffic:${settings.traffic};`\r\n  isolineParameters.rangetype = settings.rangetype\r\n\r\n  isolineParameters.start = settings.isochronesCenter.lat + ',' + settings.isochronesCenter.lng\r\n\r\n  // seconds\r\n  const ranges = []\r\n  if (settings.rangetype === 'time') {\r\n    let rangeInSeconds = settings.range.value * 60\r\n    const intervalInSeconds = settings.interval.value * 60\r\n\r\n    // to generate ranges!\r\n    while (rangeInSeconds > 0) {\r\n      ranges.push(rangeInSeconds)\r\n      rangeInSeconds -= intervalInSeconds\r\n    }\r\n\r\n    isolineParameters.range = ranges.join(',')\r\n\r\n  // meters\r\n  } else if (settings.rangetype === 'distance') {\r\n    let rangeInMeters = settings.range.value * 1000\r\n    const intervalInMeters = settings.interval.value * 1000\r\n\r\n    // to generate ranges!\r\n    while (rangeInMeters > 0) {\r\n      ranges.push(rangeInMeters)\r\n      rangeInMeters -= intervalInMeters\r\n    }\r\n\r\n    isolineParameters.range = ranges.join(',')\r\n  }\r\n  return isolineParameters\r\n}\r\n\r\nexport const requestIsochronesResults = () => ({\r\n  type: REQUEST_ISOCHRONES_RESULTS\r\n})\r\n\r\nexport const fetchHereGeocode = payload => dispatch => {\r\n\r\n  // It dispatches a further action to let our state know that requests are about to be made (loading spinner listens to this!)\r\n  dispatch(requestGeocodeResults())\r\n\r\n  // we define our url and parameters to be sent along\r\n  let url = new URL('https://geocoder.api.here.com/6.2/geocode.json'),\r\n    params = {\r\n      app_id: hereAppId,\r\n      app_code: hereAppCode,\r\n      searchtext: payload.inputValue\r\n    }\r\n\r\n  url.search = new URLSearchParams(params)\r\n\r\n  // we use the fetch API to call HERE Maps with our parameters\r\n  return fetch(url)\r\n    // when a response is returned we extract the json data\r\n    .then(response => response.json())\r\n    // and this data we dispatch for processing in processGeocodeResponse\r\n    .then(data => dispatch(processGeocodeResponse(data)))\r\n    .catch(error => console.error(error))\r\n}\r\n\r\nconst parseGeocodeResponse = (json, latLng) => {\r\n  // parsing the response, just a simple example, this could be much more complex as the response from HERE is fairly ritch\r\n  if (json.Response && json.Response.View.length > 0) {\r\n    let processedResults = []\r\n\r\n    for (const address of json.Response.View[0].Result) {\r\n      if (address.Location && address.Location.LocationType === 'point') {\r\n        processedResults.push({\r\n          title: address.Location.Address.Label,\r\n          description: address.Location.Address.PostalCode,\r\n          displayposition: {\r\n            lat: address.Location.DisplayPosition.Latitude,\r\n            lng: address.Location.DisplayPosition.Longitude\r\n          }\r\n        })\r\n      }\r\n    }\r\n    return processedResults\r\n  }\r\n}\r\n\r\nconst processGeocodeResponse = (\r\n  json\r\n) => dispatch => {\r\n  // parse the json file and dispatch the results to receiveGeocodeResults which will be reduced\r\n  const results = parseGeocodeResponse(json)\r\n  // let's let the loading spinner now that it doesn't have to spin anymore\r\n  dispatch(receiveGeocodeResults(results))\r\n}\r\n\r\nexport const receiveGeocodeResults = payload => ({\r\n  type: RECEIVE_GEOCODE_RESULTS,\r\n  results: payload\r\n})\r\n\r\nexport const requestGeocodeResults = payload => ({\r\n  type: REQUEST_GEOCODE_RESULTS,\r\n  ...payload\r\n})\r\n\r\nexport const updateTextInput = payload => ({\r\n  type: UPDATE_TEXTINPUT,\r\n  payload\r\n})\r\n\r\nexport const updateCenter = payload => ({\r\n   type: UPDATE_CENTER,\r\n   ...payload\r\n})\r\n\r\nexport const updateSettings = payload => ({\r\n   type: UPDATE_SETTINGS,\r\n   ...payload\r\n})","import {\r\n  UPDATE_TEXTINPUT,\r\n  REQUEST_GEOCODE_RESULTS,\r\n  RECEIVE_GEOCODE_RESULTS,\r\n  UPDATE_CENTER,\r\n  UPDATE_SETTINGS,\r\n  REQUEST_ISOCHRONES_RESULTS,\r\n  // new\r\n  RECEIVE_ISOCHRONES_RESULTS,\r\n} from '../actions/actions'\r\nimport { combineReducers } from 'redux'\r\n\r\n// these are our initial isochrones settings\r\nconst initialIsochronesControlsState = {\r\n  userInput: \"\",\r\n  geocodeResults: [],\r\n  isochrones: {\r\n    results: []\r\n  },\r\n  isFetching: false,\r\n  isFetchingIsochrones: false,\r\n  settings: {\r\n    isochronesCenter: {},\r\n    range: {\r\n      max: 500,\r\n      value: 60\r\n    },\r\n    interval: {\r\n      max: 60,\r\n      value: 10\r\n    },\r\n    mode: \"car\",\r\n    rangetype: \"distance\",\r\n    traffic: \"disabled\"\r\n  }\r\n}\r\n\r\n// our reducer constant returning an unchanged or updated state object depending on the users action, many cases will follow\r\nconst isochronesControls = (state = initialIsochronesControlsState, action) => {\r\n  switch (action.type) {\r\n    // when a user inputs text we update the userInput :) easy!\r\ncase UPDATE_TEXTINPUT:\r\n  return {\r\n    ...state,\r\n    userInput: action.payload.inputValue\r\n  }\r\n// let the app know the request is being made (for our spinner)\r\ncase REQUEST_GEOCODE_RESULTS:\r\n  return {\r\n    ...state,\r\n    isFetching: true\r\n  }\r\n// when results are returned by the API update the state with addresses and let the app know it is no longer fetching\r\ncase RECEIVE_GEOCODE_RESULTS:\r\n  return {\r\n    ...state,\r\n    geocodeResults: action.results,\r\n    isFetching: false\r\n  }\r\ncase REQUEST_ISOCHRONES_RESULTS:\r\n  return {\r\n    ...state,\r\n    isFetchingIsochrones: true\r\n\r\n  }\r\ncase RECEIVE_ISOCHRONES_RESULTS:\r\n  return {\r\n    ...state,\r\n    isFetchingIsochrones: false,\r\n    isochrones: {\r\n      results: action.results\r\n    }\r\n  }\r\n\r\ncase UPDATE_SETTINGS:\r\n  return {\r\n    ...state,\r\n    settings: action.settings\r\n  }\r\n// update the isochronesCenter we will use later from the coordinates of the selected address\r\ncase UPDATE_CENTER:\r\n  return {\r\n    ...state,\r\n    settings: {\r\n      ...state.settings,\r\n      isochronesCenter: action.isochronesCenter\r\n    }\r\n  }\r\n    default:\r\n      return state\r\n  }\r\n}\r\n\r\n// creates a root reducer and combines different reducers if needed\r\nconst rootReducer = combineReducers({\r\n  isochronesControls\r\n})\r\n\r\nexport default rootReducer","import * as L from \"leaflet\";\r\n\r\nvar HereTileLayers = {};\r\n\r\n// üçÇclass TileLayer.HERE\r\n// Tile layer for HERE maps tiles.\r\nHereTileLayers.HERE = L.TileLayer.extend({\r\n  options: {\r\n    subdomains: \"1234\",\r\n    minZoom: 2,\r\n    maxZoom: 18,\r\n\r\n    // üçÇoption scheme: String = 'normal.day'\r\n    // The \"map scheme\", as documented in the HERE API.\r\n    scheme: \"normal.day\",\r\n\r\n    // üçÇoption resource: String = 'maptile'\r\n    // The \"map resource\", as documented in the HERE API.\r\n    resource: \"maptile\",\r\n\r\n    // üçÇoption mapId: String = 'newest'\r\n    // Version of the map tiles to be used, or a hash of an unique map\r\n    mapId: \"newest\",\r\n\r\n    // üçÇoption format: String = 'png8'\r\n    // Image format to be used (`png8`, `png`, or `jpg`)\r\n    format: \"png8\",\r\n\r\n    // üçÇoption appId: String = ''\r\n    // Required option. The `app_id` provided as part of the HERE credentials\r\n    appId: \"\",\r\n\r\n    // üçÇoption appCode: String = ''\r\n    // Required option. The `app_code` provided as part of the HERE credentials\r\n    appCode: \"\"\r\n  },\r\n\r\n  initialize: function initialize(options) {\r\n    options = L.setOptions(this, options);\r\n\r\n    // Decide if this scheme uses the aerial servers or the basemap servers\r\n    var schemeStart = options.scheme.split(\".\")[0];\r\n    options.tileResolution = 256;\r\n\r\n    if (L.Browser.retina) {\r\n      options.tileResolution = 512;\r\n    }\r\n\r\n    //    {Base URL}{Path}/{resource (tile type)}/{map id}/{scheme}/{zoom}/{column}/{row}/{size}/{format}\r\n    //    ?app_id={YOUR_APP_ID}\r\n    //    &app_code={YOUR_APP_CODE}\r\n    //    &{param}={value}\r\n\r\n    var path =\r\n      \"/{resource}/2.1/{resource}/{mapId}/{scheme}/{z}/{x}/{y}/{tileResolution}/{format}?app_id={appId}&app_code={appCode}\";\r\n    var attributionPath =\r\n      \"/maptile/2.1/copyright/{mapId}?app_id={appId}&app_code={appCode}\";\r\n\r\n    var tileServer = \"base.maps.api.here.com\";\r\n    if (\r\n      // eslint-disable-next-line\r\n      schemeStart == \"satellite\" ||\r\n      // eslint-disable-next-line\r\n      schemeStart == \"terrain\" ||\r\n      // eslint-disable-next-line\r\n      schemeStart == \"hybrid\"\r\n    ) {\r\n      tileServer = \"aerial.maps.api.here.com\";\r\n    }\r\n    if (options.scheme.indexOf(\".traffic.\") !== -1) {\r\n      tileServer = \"traffic.maps.api.here.com\";\r\n    }\r\n\r\n    var tileUrl = \"https://{s}.\" + tileServer + path;\r\n\r\n    this._attributionUrl = L.Util.template(\r\n      \"https://1.\" + tileServer + attributionPath,\r\n      this.options\r\n    );\r\n\r\n    L.TileLayer.prototype.initialize.call(this, tileUrl, options);\r\n\r\n    this._attributionText = \"\";\r\n  },\r\n\r\n  onAdd: function onAdd(map) {\r\n    L.TileLayer.prototype.onAdd.call(this, map);\r\n\r\n    if (!this._attributionBBoxes) {\r\n      this._fetchAttributionBBoxes();\r\n    }\r\n  },\r\n\r\n  onRemove: function onRemove(map) {\r\n    L.TileLayer.prototype.onRemove.call(this, map);\r\n\r\n    this._map.attributionControl.removeAttribution(this._attributionText);\r\n\r\n    this._map.off(\"moveend zoomend resetview\", this._findCopyrightBBox, this);\r\n  },\r\n\r\n  _fetchAttributionBBoxes: function _onMapMove() {\r\n    var xmlhttp = new XMLHttpRequest();\r\n    xmlhttp.onreadystatechange = L.bind(function() {\r\n      // eslint-disable-next-line\r\n      if (xmlhttp.readyState == 4 && xmlhttp.status == 200) {\r\n        this._parseAttributionBBoxes(JSON.parse(xmlhttp.responseText));\r\n      }\r\n    }, this);\r\n    xmlhttp.open(\"GET\", this._attributionUrl, true);\r\n    xmlhttp.send();\r\n  },\r\n\r\n  _parseAttributionBBoxes: function _parseAttributionBBoxes(json) {\r\n    if (!this._map) {\r\n      return;\r\n    }\r\n    var providers = json[this.options.scheme.split(\".\")[0]] || json.normal;\r\n    for (var i = 0; i < providers.length; i++) {\r\n      if (providers[i].boxes) {\r\n        for (var j = 0; j < providers[i].boxes.length; j++) {\r\n          var box = providers[i].boxes[j];\r\n          providers[i].boxes[j] = L.latLngBounds([\r\n            [box[0], box[1]],\r\n            [box[2], box[3]]\r\n          ]);\r\n        }\r\n      }\r\n    }\r\n\r\n    this._map.on(\"moveend zoomend resetview\", this._findCopyrightBBox, this);\r\n\r\n    this._attributionProviders = providers;\r\n\r\n    this._findCopyrightBBox();\r\n  },\r\n\r\n  _findCopyrightBBox: function _findCopyrightBBox() {\r\n    if (!this._map) {\r\n      return;\r\n    }\r\n    var providers = this._attributionProviders;\r\n    var visibleProviders = [];\r\n    var zoom = this._map.getZoom();\r\n    var visibleBounds = this._map.getBounds();\r\n\r\n    for (var i = 0; i < providers.length; i++) {\r\n      if (providers[i].minLevel < zoom && providers[i].maxLevel > zoom)\r\n        if (!providers[i].boxes) {\r\n          // No boxes = attribution always visible\r\n          visibleProviders.push(providers[i]);\r\n          break;\r\n        }\r\n\r\n      for (var j = 0; j < providers[i].boxes.length; j++) {\r\n        var box = providers[i].boxes[j];\r\n        if (visibleBounds.overlaps(box)) {\r\n          visibleProviders.push(providers[i]);\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    var attributions = [\r\n      '<a href=\"https://legal.here.com/terms/serviceterms/gb/\">HERE maps</a>'\r\n    ];\r\n    // eslint-disable-next-line\r\n    for (var i = 0; i < visibleProviders.length; i++) {\r\n      var provider = visibleProviders[i];\r\n      attributions.push(\r\n        '<abbr title=\"' + provider.alt + '\">' + provider.label + \"</abbr>\"\r\n      );\r\n    }\r\n\r\n    var attributionText = \"¬© \" + attributions.join(\", \") + \". \";\r\n\r\n    if (attributionText !== this._attributionText) {\r\n      this._map.attributionControl.removeAttribution(this._attributionText);\r\n      this._map.attributionControl.addAttribution(\r\n        (this._attributionText = attributionText)\r\n      );\r\n    }\r\n  }\r\n});\r\n\r\nHereTileLayers.here = function(opts) {\r\n  return new HereTileLayers.HERE(opts);\r\n};\r\n\r\nexport default HereTileLayers;","import React from \"react\";\r\nimport { connect } from \"react-redux\";\r\nimport L from \"leaflet\";\r\nimport PropTypes from \"prop-types\";\r\nimport chroma from \"chroma-js\";\r\n\r\nimport HereTileLayers from \"./hereTileLayers\";\r\n\r\n// defining the container styles the map sits in\r\nconst style = {\r\n  width: \"100%\",\r\n  height: \"100vh\"\r\n};\r\n\r\n// using the reduced.day map styles, have a look at the imported hereTileLayers for more\r\nconst hereReducedDay = HereTileLayers.here({\r\n  appId: \"jKco7gLGf0WWlvS5n2fl\",\r\n  appCode: \"HQnCztY23zh2xiTPCFiTMA\",\r\n  scheme: \"reduced.day\"\r\n});\r\n\r\n// for this app we create two leaflet layer groups to control, one for the isochrone centers and one for the isochrone contours\r\nconst markersLayer = L.featureGroup();\r\nconst isochronesLayer = L.featureGroup();\r\n\r\n// we define our bounds of the map\r\nconst southWest = L.latLng(-90, -180),\r\n  northEast = L.latLng(90, 180),\r\n  bounds = L.latLngBounds(southWest, northEast);\r\n\r\n// a leaflet map consumes parameters, I'd say they are quite self-explanatory\r\nconst mapParams = {\r\n  center: [25.95681, -35.729687],\r\n  zoomControl: false,\r\n  maxBounds: bounds,\r\n  zoom: 2,\r\n  layers: [markersLayer, isochronesLayer, hereReducedDay]\r\n};\r\n\r\n// this you have seen before, we define a react component\r\nclass Map extends React.Component {\r\n  static propTypes = {\r\n    isochronesControls: PropTypes.object.isRequired,\r\n    mapEvents: PropTypes.object,\r\n    dispatch: PropTypes.func.isRequired\r\n  };\r\n\r\n  addIsochrones() {\r\n    isochronesLayer.clearLayers();\r\n\r\n    const isochrones = this.props.isochronesControls.isochrones.results;\r\n\r\n    if (isochrones.length > 0) {\r\n      let cnt = 0;\r\n\r\n      const scaleHsl = chroma\r\n        .scale([\"#f44242\", \"#f4be41\", \"#41f497\"])\r\n        .mode(\"hsl\")\r\n        .colors(isochrones.length);\r\n\r\n      for (const isochrone of isochrones) {\r\n        for (const isochroneComponent of isochrone.component) {\r\n          L.polygon(\r\n            isochroneComponent.shape.map(function(coordString) {\r\n              return coordString.split(\",\");\r\n            }),\r\n            {\r\n              fillColor: scaleHsl[cnt],\r\n              weight: 2,\r\n              opacity: 1,\r\n              color: \"white\",\r\n              pane: \"isochronesPane\"\r\n            }\r\n          ).addTo(isochronesLayer);\r\n        }\r\n        cnt += 1;\r\n      }\r\n\r\n      this.map.fitBounds(isochronesLayer.getBounds());\r\n    }\r\n  }\r\n\r\n  addIsochronesCenter() {\r\n    // clear the markers layer beforehand\r\n    markersLayer.clearLayers();\r\n\r\n    const isochronesCenter = this.props.isochronesControls.settings\r\n      .isochronesCenter;\r\n\r\n    // does this object contain a latitude and longitude?\r\n    if (isochronesCenter.lat && isochronesCenter.lng) {\r\n      // we are creating a leaflet circle marker with a minimal tooltip\r\n      L.circleMarker(isochronesCenter)\r\n        .addTo(markersLayer)\r\n        .bindTooltip(\r\n          \"latitude: \" +\r\n            isochronesCenter.lat +\r\n            \", \" +\r\n            \"longitude: \" +\r\n            isochronesCenter.lng,\r\n          {\r\n            permanent: false\r\n          }\r\n        )\r\n        .openTooltip();\r\n\r\n      // set the map view\r\n      this.map.setView(isochronesCenter, 7);\r\n    }\r\n  }\r\n\r\n  componentDidUpdate() {\r\n    this.addIsochronesCenter();\r\n    this.addIsochrones();\r\n  }\r\n\r\n  // and once the component has mounted we add everything to it\r\n  componentDidMount() {\r\n    // our map!\r\n    this.map = L.map(\"map\", mapParams);\r\n\r\n    // we create a leaflet pane which will hold all isochrone polygons with a given opacity\r\n    var isochronesPane = this.map.createPane(\"isochronesPane\");\r\n    isochronesPane.style.opacity = 0.9;\r\n\r\n    // our basemap and add it to the map\r\n    const baseMaps = {\r\n      \"HERE reduced.day\": hereReducedDay\r\n    };\r\n    L.control.layers(baseMaps).addTo(this.map);\r\n\r\n    // we do want a zoom control\r\n    L.control\r\n      .zoom({\r\n        position: \"topright\"\r\n      })\r\n      .addTo(this.map);\r\n\r\n    // and for the sake of advertising your company, you may add a logo to the map\r\n    const brand = L.control({\r\n      position: \"bottomright\"\r\n    });\r\n    brand.onAdd = function(map) {\r\n      var div = L.DomUtil.create(\"div\", \"brand\");\r\n      div.innerHTML =\r\n        '<a href=\"https://gis.ops.com\" target=\"_blank\"><img src=\"http://104.199.51.11:8083/wp-content/uploads/2018/11/gisops.png\" width=\"150px\"></img></a>';\r\n      return div;\r\n    };\r\n    this.map.addControl(brand);\r\n  }\r\n\r\n  // don't forget to render it :-)\r\n  render() {\r\n    return <div id=\"map\" style={style} />;\r\n  }\r\n}\r\n\r\n// and we already map the redux store to properties which we will start soon\r\nconst mapStateToProps = state => {\r\n  const isochronesControls = state.isochronesControls;\r\n  return {\r\n    isochronesControls\r\n  };\r\n};\r\n\r\nexport default connect(mapStateToProps)(Map);","import React from \"react\"\r\nimport PropTypes from \"prop-types\"\r\nimport { connect } from \"react-redux\"\r\nimport { Slider } from \"react-semantic-ui-range\"\r\nimport { Label, Button, Divider } from \"semantic-ui-react\"\r\n\r\n// we need just one action in this component to update settings made\r\nimport { updateSettings } from \"../actions/actions\"\r\n\r\nclass Settings extends React.Component {\r\n\r\n  static propTypes = {\r\n    dispatch: PropTypes.func.isRequired,\r\n    controls: PropTypes.object.isRequired\r\n  }\r\n\r\n  // dispatches the action\r\n  updateSettings() {\r\n    const { controls, dispatch } = this.props\r\n\r\n    dispatch(\r\n      updateSettings({\r\n        settings: controls.settings\r\n      })\r\n    )\r\n  }\r\n\r\n  // we are making settings directly in the controls.settings object which is being passed on to the updateSettings() function up top\r\n  handleSettings(settingName, setting) {\r\n    const { controls } = this.props\r\n\r\n    controls.settings[settingName] = setting\r\n\r\n    this.updateSettings()\r\n  }\r\n\r\n  // this looks complex but it isn't, we basically want to make sure the the interval settings maximum can never be greater than the range maximum\r\n  alignRangeInterval() {\r\n    const { controls } = this.props\r\n\r\n    if (\r\n      controls.settings.range.value < controls.settings.interval.value ||\r\n      controls.settings.interval.value === \"\"\r\n    ) {\r\n      controls.settings.interval.value = controls.settings.range.value\r\n    }\r\n\r\n    controls.settings.interval.max = controls.settings.range.value\r\n  }\r\n\r\n  render() {\r\n    const { controls } = this.props\r\n\r\n    // depending on what the user selected we obviously want to show the correct units\r\n    const rangetype =\r\n      controls.settings.rangetype === \"time\" ? \" minutes\" : \" kilometers\"\r\n\r\n    // our settings which are needed for the range slider, read more here https://github.com/iozbeyli/react-semantic-ui-range\r\n    const rangeSettings = {\r\n      settings: {\r\n        ...controls.settings.range,\r\n        min: 1,\r\n        step: 1,\r\n        start: controls.settings.range.value,\r\n        // when the slider is moved, we want to update our settings and make sure the maximums align\r\n        onChange: value => {\r\n          controls.settings.range.value = value\r\n\r\n          this.alignRangeInterval()\r\n          this.updateSettings()\r\n        }\r\n      }\r\n    }\r\n    // same as above, just for the interval slider this time\r\n    const intervalSettings = {\r\n      settings: {\r\n        ...controls.settings.interval,\r\n        min: 1,\r\n        step: 1,\r\n        start: controls.settings.interval.value,\r\n        onChange: value => {\r\n          controls.settings.interval.value = value\r\n          this.updateSettings()\r\n        }\r\n      }\r\n    }\r\n    // we have different kinds of settings in here. The components should be quite self-explanatory. Whenever a button is clicked we call handleSettings() and this way pass on our setting through to our state.\r\n    return (\r\n      <div className=\"mt3\">\r\n        <Divider />\r\n        <Label size=\"small\">{\"Mode of transport\"}</Label>\r\n        <div className=\"mt3\">\r\n          <Button.Group basic size=\"small\">\r\n            {Object.keys({ pedestrian: {}, car: {} }).map((key, i) => (\r\n              <Button\r\n                active={key === controls.settings.mode}\r\n                key={i}\r\n                mode={key}\r\n                onClick={() => this.handleSettings(\"mode\", key)}\r\n              >\r\n                {key}\r\n              </Button>\r\n            ))}\r\n          </Button.Group>\r\n          {controls.settings.mode === \"car\" && (\r\n            <div>\r\n              <Divider />\r\n              <Label size=\"small\">{\"Traffic\"}</Label>\r\n              <div className=\"mt3\">\r\n                <Button.Group basic size=\"small\">\r\n                  {Object.keys({ enabled: {}, disabled: {} }).map((key, i) => (\r\n                    <Button\r\n                      active={key === controls.settings.traffic}\r\n                      key={i}\r\n                      mode={key}\r\n                      onClick={() => this.handleSettings(\"traffic\", key)}\r\n                    >\r\n                      {key}\r\n                    </Button>\r\n                  ))}\r\n                </Button.Group>\r\n              </div>\r\n            </div>\r\n          )}\r\n        </div>\r\n        <Divider />\r\n        <Label size=\"small\">{\"Range type\"}</Label>\r\n        <div className=\"mt3\">\r\n          <Button.Group basic size=\"small\">\r\n            {Object.keys({ distance: {}, time: {} }).map((key, i) => (\r\n              <Button\r\n                active={key === controls.settings.rangetype}\r\n                key={i}\r\n                mode={key}\r\n                onClick={() => this.handleSettings(\"rangetype\", key)}\r\n              >\r\n                {key}\r\n              </Button>\r\n            ))}\r\n          </Button.Group>\r\n        </div>\r\n        <Divider />\r\n        <Label size=\"small\">{\"Maximum range\"}</Label>\r\n        <div className=\"mt3\">\r\n          <Slider\r\n            discrete\r\n            color=\"grey\"\r\n            value={controls.settings.range.value}\r\n            inverted={false}\r\n            settings={rangeSettings.settings}\r\n          />\r\n          <div className=\"mt2\">\r\n            <Label className=\"mt2\" color=\"grey\" size={\"mini\"}>\r\n              {controls.settings.range.value + rangetype}\r\n            </Label>\r\n          </div>\r\n        </div>\r\n        <Divider />\r\n        <Label size=\"small\">{\"Interval step\"}</Label>\r\n        <div className=\"mt3\">\r\n          <Slider\r\n            discrete\r\n            color=\"grey\"\r\n            value={controls.settings.interval.value}\r\n            inverted={false}\r\n            settings={intervalSettings.settings}\r\n          />\r\n          <div className=\"mt2\">\r\n            <Label className=\"mt2\" color=\"grey\" size={\"mini\"}>\r\n              {controls.settings.interval.value + rangetype}\r\n            </Label>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    )\r\n  }\r\n}\r\n\r\nconst mapStateToProps = state => {\r\n  const controls = state.isochronesControls\r\n  return {\r\n    controls\r\n  }\r\n}\r\n\r\nexport default connect(mapStateToProps)(Settings)","import React from \"react\";\r\nimport PropTypes from \"prop-types\";\r\nimport { connect } from \"react-redux\";\r\n\r\n// we are importing some of the beautiful semantic UI react components\r\nimport { Segment, Search, Divider, Button } from \"semantic-ui-react\";\r\n\r\n// here are our first two actions, we will be adding them in the next step, bare with me!\r\nimport {\r\n  updateTextInput,\r\n  fetchHereGeocode,\r\n  updateCenter,\r\n  fetchHereIsochrones\r\n} from \"../actions/actions\";\r\n\r\nimport Settings from \"./Settings\";\r\n\r\n// to wait for the users input we will add debounce, this is especially useful for \"postponing\" the geocode requests\r\nimport { debounce } from \"throttle-debounce\";\r\n\r\n// some inline styles (we should move these to our index.css at one stage)\r\nconst segmentStyle = {\r\n  zIndex: 999,\r\n  position: \"absolute\",\r\n  width: \"400px\",\r\n  top: \"10px\",\r\n  left: \"10px\",\r\n  maxHeight: \"calc(100vh - 5vw)\",\r\n  overflow: \"auto\",\r\n  padding: \"20px\"\r\n};\r\n\r\nclass Control extends React.Component {\r\n  static propTypes = {\r\n    userTextInput: PropTypes.string.isRequired,\r\n    results: PropTypes.array.isRequired,\r\n    isFetching: PropTypes.bool.isRequired,\r\n    dispatch: PropTypes.func.isRequired,\r\n    isochronesCenter: PropTypes.object,\r\n    isFetchingIsochrones: PropTypes.bool.isRequired\r\n  };\r\n\r\n  constructor(props) {\r\n    super(props);\r\n    // binding this to the handleSearchChange method\r\n    this.handleSearchChange = this.handleSearchChange.bind(this);\r\n    // we are wrapping fetchGeocodeResults in a 1 second debounce\r\n    this.fetchGeocodeResults = debounce(1000, this.fetchGeocodeResults);\r\n  }\r\n\r\n  // if the input has changed... fetch some results!\r\n  handleSearchChange = event => {\r\n    const { dispatch } = this.props;\r\n\r\n    dispatch(\r\n      updateTextInput({\r\n        inputValue: event.target.value\r\n      })\r\n    );\r\n    this.fetchGeocodeResults();\r\n  };\r\n\r\n  // if a user selects one of the geocode results update the input text field and set our center coordinates\r\n  handleResultSelect = (e, { result }) => {\r\n    const { dispatch } = this.props;\r\n\r\n    dispatch(\r\n      updateTextInput({\r\n        inputValue: result.title\r\n      })\r\n    );\r\n\r\n    dispatch(\r\n      updateCenter({\r\n        isochronesCenter: result.displayposition\r\n      })\r\n    );\r\n  };\r\n\r\n  // our method to fire a geocode request\r\n  fetchGeocodeResults() {\r\n    const { dispatch, userTextInput } = this.props;\r\n    // If the text input has more then 0 characters..\r\n    if (userTextInput.length > 0) {\r\n      dispatch(\r\n        fetchHereGeocode({\r\n          inputValue: userTextInput\r\n        })\r\n      );\r\n    }\r\n  }\r\n\r\n  handleFetchIsochrones = () => {\r\n    const { dispatch, settings } = this.props;\r\n\r\n    if (settings.isochronesCenter.lat && settings.isochronesCenter.lng) {\r\n      dispatch(fetchHereIsochrones({ settings }));\r\n    }\r\n  };\r\n\r\n  render() {\r\n    // The following constants are used in our search input which is also a semanticUI react component <Search... />\r\n    const {\r\n      isFetching,\r\n      userTextInput,\r\n      results,\r\n      settings,\r\n      isFetchingIsochrones\r\n    } = this.props;\r\n\r\n    // if an address is selected we will return true to enable our button!\r\n    const isResultSelected = () => {\r\n      if (settings.isochronesCenter.lat && settings.isochronesCenter.lng)\r\n        return false;\r\n      return true;\r\n    };\r\n\r\n    return (\r\n      <div>\r\n        <Segment style={segmentStyle}>\r\n          <div>\r\n            <span>\r\n              Isochrones powered by <strong>HERE Maps</strong>\r\n            </span>\r\n          </div>\r\n          <Divider />\r\n          {/* they are tachyons css classes by the way..*/}\r\n          <div className=\"flex justify-between items-center mt3\">\r\n            {/* more about the props can be read here https://react.semantic-ui.com/modules/search the most important part to mention here are our objects being fed to it. When a user types text into the input handleSearchChange is called. When the geocode API is called the variable loading will be set true to show the spinner (coming from state). The results are shown in a dropdown list (also coming from the state) and the value shown in the input is userTextInput (..also from state). */}\r\n            <Search\r\n              onSearchChange={this.handleSearchChange}\r\n              onResultSelect={this.handleResultSelect}\r\n              type=\"text\"\r\n              fluid\r\n              input={{ fluid: true }}\r\n              loading={isFetching}\r\n              className=\"flex-grow-1 mr2\"\r\n              results={results}\r\n              value={userTextInput}\r\n              placeholder=\"Find Address ...\"\r\n            />\r\n            <Button\r\n              circular\r\n              loading={isFetchingIsochrones}\r\n              disabled={isResultSelected()}\r\n              color=\"purple\"\r\n              icon=\"globe\"\r\n              onClick={this.handleFetchIsochrones}\r\n            />\r\n          </div>\r\n          <div className=\"mt2\">\r\n            <Settings />\r\n          </div>\r\n        </Segment>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\n//\r\nconst mapStateToProps = state => {\r\n  const userTextInput = state.isochronesControls.userInput;\r\n  const results = state.isochronesControls.geocodeResults;\r\n  const isFetching = state.isochronesControls.isFetching;\r\n\r\n  // new\r\n  const settings = state.isochronesControls.settings;\r\n  // new\r\n  const isFetchingIsochrones = state.isochronesControls.isFetchingIsochrones;\r\n\r\n  return {\r\n    userTextInput,\r\n    results,\r\n    isFetching,\r\n    settings,\r\n    isFetchingIsochrones\r\n  };\r\n};\r\n\r\nexport default connect(mapStateToProps)(Control);","import React from 'react'\r\nimport Map from './Map/Map'\r\nimport Controls from './Controls/Control'\r\n\r\nclass App extends React.Component {\r\n\r\n  render() {\r\n    return (\r\n      <div>\r\n        <Map />\r\n\t<Controls />\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default App","import React from 'react'\r\nimport { render } from 'react-dom'\r\n\r\nimport { createStore, applyMiddleware } from 'redux'\r\nimport { composeWithDevTools } from 'redux-devtools-extension'\r\nimport { Provider } from 'react-redux'\r\nimport thunk from 'redux-thunk'\r\nimport { createLogger } from 'redux-logger'\r\n\r\nimport reducer from './reducers'\r\nimport App from './App'\r\nimport './index.css' // postCSS import of CSS module\r\n\r\nconst middleware = [thunk]\r\n\r\nconst store = createStore(\r\n  reducer,\r\n  composeWithDevTools(applyMiddleware(...middleware))\r\n)\r\n\r\nrender(\r\n  <Provider store={store}>\r\n    {' '}\r\n    <App />\r\n  </Provider>,\r\n  document.getElementById('root')\r\n)"],"sourceRoot":""}